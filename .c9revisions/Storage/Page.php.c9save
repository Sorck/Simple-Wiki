{"ts":1356882696503,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n\n/**\n * smWiki Page Storage Class\n *\n * This deals with a Page object - a Wiki data construct. It is designed so that\n * we don't have to run database queries in our controllers. It also abstracts\n * some thing so we can change how we store data without changing the Wiki\n * controllers.\n *\n * @package smWiki\n * @author smWiki Dev Team\n * @license MPL 1.1\n * @version 1.0 Alpha\n *\n * The contents of this file are subject to the Mozilla Public License Version 1.1\n * (the \"License\"); you may not use this package except in compliance with the\n * License. You may obtain a copy of the License at http://www.mozilla.org/MPL/\n *\n * The Original Code is smWiki.\n *\n * The Initial Developer of the Original Code is the smWiki project.\n *\n * Portions created by the Initial Developer are Copyright (C) 2012\n * the Initial Developer. All Rights Reserved.\n */\n\nnamespace smCore\\smWiki\\Storage;\n\nuse smCore\\Application, smCore\\Exception;\n\n/**\n * @todo Enable creation of a page object from an existing\n * array of page data.\n */\nclass Page implements \\ArrayAccess, \\Iterator, \\Countable\n{\n\t/**\n\t * @var array Stores internal page data. Access using get method.\n\t * @todo make this array contain default values\n\t */\n\tprotected $_data = array();\n\t/**\n\t * @var array Which variables have been modified?\n\t */\n\tprotected $_modified = array();\n\t/**\n\t * @var array Lazy load variables are stored here as they're not always needed.\n\t */\n\tprotected $_lazy = array(\n\t\t// returns how many revisions this page has had\n\t\t'total_revisions' => '_lazyTotalRevisions',\n\t\t// this is here due to it saving in a different table\n\t\t'urlname' => '_lazyUrlname',\n\t);\n\t/**\n\t * @var array A list of conversions between database collumn names and page collumn names.\n\t */\n\tprotected $_db_name_convert = array(\n\t\t'id_revision' => 'revision',\n\t);\n\t\n\t/**\n\t * \n\t * @param string $name The name to convert to the database collumn name.\n\t * @return string The database collumn name.\n\t */\n\tprotected function _nameToDBName($name)\n\t{\n\t\tthrow new Exception('smwiki.storage.deprecetated.n2');\n\t\t// flip it so we can easily return what we need\n\t\t$flipped = array_flip($this->_db_name_convert);\n\t\t// if it exists in $flipped then the name is different, else the same\n\t\treturn isset($flipped[$name]) ? $flipped[$name] : $name;\n\t}\n\n\t/**\n\t * \n\t * @param mixed $identifier A string of the page's URLNAME or the ID of it's revision\n\t */\t\n\tpublic function __construct($identifier = null)\n\t{\n\t\t// grab our database connection\n\t\t#$db = Application::get('db');\n\t\t#$cache = Application::get('cache');\n\t\t\n\t\t// a null identifier means we're creating a page\n\t\tif($identifier === null)\n\t\t{\n\t\t\t// set to our defaults...\n\t\t\t$this->_setFromRow(array());\n\t\t}\n\t\t// an array means we're trying to initialise a page with that data\n\t\telseif(is_array($identifier))\n\t\t{\n\t\t\t// @todo might need to check how good the array is...\n\t\t\t$this->_setFromRow($identifier);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new Exception('smwiki.storage.deprecetated.con');\n\t\t}\n\t}\n\t\n\t/**\n\t * Make a database row into a page object.\n\t * \n\t * This function takes a wiki row and sets the Page object structure.\n\t * Also loads some additional data about the page.\n\t * \n\t * @param array $row A row from the wiki_content table.\n\t */\n\tprotected function _setFromRow(array $row)\n\t{\n\t\t// make sure we have an array\n\t\t// @todo Surely php will error out first as we require an array?\n\t\tif(!is_array($row))\n\t\t{\n\t\t\t// this is quite a major internal issue...\n\t\t\tthrow new Exception('smwiki.storage.internal_error');\n\t\t}\n\t\t// @todo verify this array\n\t\t$this->_data += $row;\n\t\t//throw new Exception('smwiki.storage.deprecetated');\n\t\t// get our current error reporting level\n\t\t/*$e = error_reporting();\n\t\t// surpress undefined index errors...\n\t\terror_reporting(~E_NOTICE);\n\t\t$this->_data += $row;\n\t\t// merge the row data into our protected arra\n\t\t$this->_data += array(\n\t\t\t'name' => $row['realname'] ?: '',\n\t\t\t'urlname' => $row['urlname'] ?: '',\n\t\t\t'parsed_content' => $row['parsed_content'] ?: '',\n\t\t\t'unparsed_content' => $row['unparsed_content'] ?: '',\n\t\t\t'revision' => $row['id_revision'] ?: 0,\n\t\t\t'id_editor' => $row['id_editor'] ?: 0,\n\t\t\t'is_new' => $row['id_revision'] ? false : true,\n\t\t\t'time' => $row['time'] ?: 0,\n\t\t\t'ip' => $row['ip'] ?: '127.0.0.1',\n\t\t);\n\t\t// revert error reporting level\n\t\terror_reporting($e);*/\n\t}\n\t\n\t/**\n\t * Saves the current page data as a new revision\n\t */\n\tpublic function save()\n\t{throw new Exception('smwiki.storage.deprecetated_save');\n\t\t// @todo\n\t\t// build our insert query\n\t\t// we can only save if values have been modified\n\t\tif(empty($this->_modified))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\t// our known page data values\n\t\t$known = array(\n\t\t\t'parsed_content' => 'text',\n\t\t\t'unparsed_content' => 'text',\n\t\t\t//'urlname' => 'text',\n\t\t\t'name' => 'text',\n\t\t\t'id_editor' => 'int',\n\t\t\t'ip' => 'int',\n\t\t\t'time' => 'int',\n\t\t);\n\t\t// we need to do these by lazy functions\n\t\t$toDoByLazy = array();\n\t\t// go through the modified values and see which need lazy updating and which don't\n\t\tforeach($this->_modified as $modified => $b)\n\t\t{\n\t\t\tif(isset($this->_lazy[$modified]))\n\t\t\t{\n\t\t\t\t$toDoByLazy[] = $modified;\n\t\t\t\tunset($this->_modified[$modified]);\n\t\t\t}\n\t\t\t// if it's also not known then we have issues\n\t\t\tif(!isset($known[$modified]) && $modified !== 'urlname')\n\t\t\t{\n\t\t\t\tthrow new Exception(array('smwiki.storage.unknown_changed_key', $modified));\n\t\t\t}\n\t\t}\n\t\t// build our known database query\n\t\t$qry = 'INSERT INTO {db_prefix}wiki_content ';\n\t\t$colls = array();\n\t\t$values = array();\n\t\t$toPass = array();\n\t\tforeach($known AS $m => $n)\n\t\t{\n\t\t\t$colls[] = $this->_nameToDBName($m);\n\t\t\t$values[] = '{' . $n . ':' . $m . '}';\n\t\t\t$toPass[$m] = $this[$m];\n\t\t}\n\t\t// put everything together now\n\t\t$qry .= '(' . implode(',', $colls) .')' .\n\t\t\t'VALUES (' . implode(',', $values).')';\n\t\t// get our database connection\n\t\t$db = Application::get('db');\n\t\t// now run the query\n\t\t$db->query($qry, $toPass);\n\t\t// get our new id_revision\n\t\t$this['revision'] = $db->lastInsertId();\n\t\t// @todo update the wiki_urls table? NB should be done lazily now\n\t\t// do our lazy variable saving\n\t\tforeach($toDoByLazy as $lazy)\n\t\t{\n\t\t\t// this just looks confusing... but it works :P\n\t\t\t$this->{$this->_lazy[$lazy]}($lazy, $this->_data[$lazy]);\n\t\t}\n\t}\n\t\n\t/**\n\t * Sets wiki page data\n\t * \n\t * @param type $data An array of keys that you want to set to their corresponding value.\n\t * @param bool $_do_clean Do we want to clean the data? This is for internal storage class usage.\n\t */\n\tpublic function set($data, $_do_clean = true)\n\t{\n\t\t// cycle through all of the $data key/value pairs\n\t\tforeach($data as $k => $v)\n\t\t{\n\t\t\t// don't bother if it wouldn't change anything\n\t\t\tif(isset($this->_data[$k]) && $v === $this->_data[$k])\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// if this is being accessed from an external source then we'll be data cleaning\n\t\t\tif($_do_clean)\n\t\t\t{\n\t\t\t\t// some things need special cleaning requirements\n\t\t\t\tswitch($k)\n\t\t\t\t{\n\t\t\t\t\t// if we're changing the name then we also need to change the urlname\n\t\t\t\t\tcase 'name':\n\t\t\t\t\t\t// make sure it's polished\n\t\t\t\t\t\t$this->_data['urlname'] = $this->_hrefMake($v);\n\t\t\t\t\t\t$this->_modified[$k] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// this one is just to make it easier to set the content...\n\t\t\t\t\tcase 'content':\n\t\t\t\t\t\t$this->_data['unparsed_content'] = $v;\n\t\t\t\t\t\t// we really should clean this one out... HTML purify it?\n\t\t\t\t\t\t$this->_data['parsed_content'] = $v;\n\t\t\t\t\t\t// and we've modified them both...\n\t\t\t\t\t\t$this->_modifed += array(\n\t\t\t\t\t\t\t'parsed_content' => true,\n\t\t\t\t\t\t\t'unparsed_content' => true,\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// continue to next foreach value because we don't want to change the content key\n\t\t\t\t\t\tcontinue 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$v = is_array($v) ? new \\smCore\\smWiki\\Library\\WikiArray($v) : $v;\n\t\t\t// if it's a lazy variable then it can set itself...\n\t\t\tif(isset($this->_lazy[$k]))\n\t\t\t{\n\t\t\t\t$this->{$this->_lazy[$k]}();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// yep, we've modified this variable\n\t\t\t\t$this->_modified[$k] = true;\n\t\t\t\t// and remember to store the value\n\t\t\t\t$this->_data[$k] = $v;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * \n\t * @param string $name The key that you wish to access.\n\t * @return mixed The contents of $name or null\n\t */\n\tpublic function get($name)\n\t{\n\t\t// if it exists then return it\n\t\tif(isset($this->_data[$name]))\n\t\t{\n\t\t\treturn $this->_data[$name];\n\t\t}\n\t\t// is it supposed to be lazy-loaded?\n\t\telseif(isset($this->_lazy[$name]))\n\t\t{throw new Exception('smwiki.storage.deprecetated');\n\t\t\t$cache = Application::get('cache');\n\t\t\t// try a cache load\n\t\t\tif(false !== $_from_cache = $cache->load('wiki_page_' . $this['revision'] . '_lazy_' . $name))\n\t\t\t{\n\t\t\t\t$this->_data += $_from_cache;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// get all keys we have\n\t\t\t\t$keys = array();\n\t\t\t\tforeach($this->_data as $k => $v)\n\t\t\t\t{\n\t\t\t\t\t$keys[] = $k;\n\t\t\t\t}\n\t\t\t\t// this should call a setter for that variable (and perhaps others)\n\t\t\t\t$this->{$this->_lazy[$name]}();\n\t\t\t\t// now get our new keys\n\t\t\t\t$newdata = array();\n\t\t\t\tforeach($this->_data as $k => $v)\n\t\t\t\t{\n\t\t\t\t\tif(!in_array($k, $keys))\n\t\t\t\t\t{\n\t\t\t\t\t\t$newdata[$k] = $v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// cache the $newdata\n\t\t\t\t$cache->save('wiki_page_' . $this['revision'] . '_lazy_' . $name, $newdata);\n\t\t\t\t\n\t\t\t}\n\t\t\t// now see if it exists again...\n\t\t\tif(isset($this->_data[$name]))\n\t\t\t{\n\t\t\t\treturn $this->_data[$name];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// this shouldn't be happening so log a debug message\n\t\t\t\t// @todo log these issues\n\t\t\t\t// and just return a blank value\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// meh... doesn't exist then :(\n\t\telse\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Cleans the cache of data about this page.\n\t * \n\t * @param bool $all_revisions Should only the current revision be cleaned or all revisions?\n\t */\n\tpublic function flush($all_revisions = false)\n\t{\n\t\t// grab the cache\n\t\t$cache = Application::get('cache');\n\t\t// remove the generic cache of this page\n\t\t$cache->remove('wiki_page_name_' . $this['urlname']);\n\t\t// if we're doing them all then we have to do this tactfully...\n\t\tif($all_revisions === true)\n\t\t{\n\t\t\t$res = Application::get('db')->query('SELECT id_revision\n\t\t\t\tFROM {db_prefix}wiki_content\n\t\t\t\tWHERE name = {text:name}');\n\t\t\twhile($row = $res->fetch())\n\t\t\t{\n\t\t\t\t$this->_flushRevision($row['id_revision']);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$this->_flushRevision($this['revision']);\n\t\t}\n\t}\n\t\n\t/**\n\t * Internal function to flush a particular wiki page revision from the cache.\n\t * \n\t * @param mixed $id An int or array_int.\n\t * @throws \\smCore\\Exception\n\t */\n\tprotected function _flushRevision($id)\n\t{throw new Exception('smwiki.storage.deprecetated');\n\t\t// better be an integer...\n\t\tif(!is_int($id))\n\t\t{\n\t\t\tthrow new Exception('smwiki.storage.flush.not_int_revision');\n\t\t}\n\t\t// get the cache\n\t\t$cache = Application::get('cache');\n\t\t// delete the plain old revision data\n\t\t$cache->remove('wiki_page_revision_' . $id);\n\t\t// now remove all lazy load cache data\n\t\tforeach($this->_lazy as $name => $method)\n\t\t{\n\t\t\t$cache->remove('wiki_page_' . $this['revision'] . '_lazy_' . $name);\n\t\t}\n\t}\n\t\n\t/**\n\t * \n\t * @param type $key\n\t * @param type $value\n\t * @throws Exception\n\t */\n\tprotected function _lazyTotalRevisions($key = null, $value = null)\n\t{throw new Exception('smwiki.storage.deprecetated');\n\t\t// are we saving it?\n\t\tif(!is_null($key))\n\t\t{\n\t\t\t// sorry but we can't change the total number of revisions\n\t\t\tif($key === 'total_revisions')\n\t\t\t{\n\t\t\t\tthrow new Exception(array('smwiki.storage.lazy.cannot_set', $key));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// erm... why're we being told to set this? :-\\\n\t\t\t\tthrow new Exception(array('smwiki.storage.lazy.wrong_setter', $key));\n\t\t\t}\n\t\t}\n\t\t// must just be loading\n\t\telse\n\t\t{\n\t\t\t// count up the revisions\n\t\t\t$row = Application::get('db')->query('SELECT count(id_revision) AS cnt\n\t\t\t\tFROM {db_prefix}wiki_content\n\t\t\t\tWHERE name = {text:name}',\n\t\t\t\tarray(\n\t\t\t\t\t'name' => $this->get('name'),\n\t\t\t\t))->fetch();\n\t\t\t// and now set the value\n\t\t\t$this->_data['total_revisions'] = $row['cnt'];\n\t\t}\n\t}\n\t\n\t/**\n\t * \n\t * @param type $key\n\t * @param type $value\n\t */\n\tprotected function _lazyUrlname($key = null, $value = null)\n\t{throw new Exception('smwiki.storage.deprecetated');\n\t\tif(!is_null($key))\n\t\t{\n\t\t\t// we must be saving then\n\t\t\tApplication::get('db')->query('REPLACE INTO {db_prefix}wiki_urls\n\t\t\t\t(urlname, realname, latest_revision)\n\t\t\t\tVALUES({text:urlname}, {text:realname}, {int:latest_revision})', array(\n\t\t\t\t\t'urlname' => $this['urlname'],\n\t\t\t\t\t'realname' => $this['name'],\n\t\t\t\t\t'latest_revision' => $this['revision'],\n\t\t\t\t));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// honestly, WTH are we being set here for?\n\t\t\tthrow new Exception('smwiki.storage.lazy.not_implemented');\n\t\t}\n\t}\n\t\t\n\t/**\n\t * Encodes a page name for a Wiki URL.\n\t * \n\t * This is designed to encode a page name for use in a URL.\n\t * It is only to be used when saving a page.\n\t * \n\t * @param string $name The non-encoded page name.\n\t * @return string The encoded page name.\n\t */\n\tprotected function _hrefMake($name)\n\t{\n\t\t// clean out bad characters\n\t\t$name = str_replace(array(\n\t\t\t\"\\n\", \"\\t\", ' '\n\t\t), '_', $name);\n\t\t\n\t\t// now urlencode it\n\t\t$name = urlencode($name);\n\t\t\n\t\t// silly encryption of slashes needs undoing...\n\t\treturn str_replace('%2F', '/', $name);\n\t}\n\n\t/**\n\t * @param mixed $offset \n\t * @return bool Whether or not $offset exixts.\n\t */\n\tpublic function offsetExists($offset)\n\t{\n\t\treturn isset($this->_data[$offset]);\n\t}\n\n\t/**\n\t * @param mixed $offset The key you want to find the value of.\n\t * @return mixed The value of key $offset.\n\t */\n\tpublic function offsetGet($offset)\n\t{\n\t\treturn $this->get($offset);\n\t}\n\n\t/**\n\t * \n\t * @param type $offset The key to set the value of.\n\t * @param type $value The value to set.\n\t */\n\tpublic function offsetSet($offset, $value)\n\t{\n\t\t// just use our existing function\n\t\t$this->set(array($offset => $value));\n\t}\n\n\t/**\n\t * @param type $offset The key to unset.\n\t */\n\tpublic function offsetUnset($offset)\n\t{\n\t\t// if it already exists then yes, we have changed it's value\n\t\tif(isset($this->_data[$offset]))\n\t\t{\n\t\t\t$this->_modified[$offset] = true;\n\t\t}\n\t\t// null'ing it is better for us...\n\t\t$this->_data[$offset] = null;\n\t}\n\t\n\tpublic function rewind()\n\t{\n\t\treset($this->_data);\n\t}\n\t\n\tpublic function current()\n\t{\n\t\treturn current($this->_data);\n\t}\n\t\n\tpublic function key()\n\t{\n\t\treturn key($this->_data);\n\t}\n\t\n\tpublic function next()\n\t{\n\t\treturn next($this->_data);\n\t}\n\t\n\tpublic function valid()\n\t{\n\t\treturn $this->current() !== false;\n\t}\n\t\n\tpublic function count()\n\t{\n\t\treturn count($this->_data);\n\t}\n}"]],"start1":0,"start2":0,"length1":0,"length2":14328}]],"length":14328}
